package com.library.application.controller;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.library.application.domain.Author;
import com.library.application.domain.Collaborator;
import com.library.application.domain.Expression;
import com.library.application.domain.Language;
import com.library.application.domain.Subject;
import com.library.application.domain.WRelationship;
import com.library.application.domain.WRelationshipType;
import com.library.application.domain.Work;
import com.library.application.persistence.AuthorRepository;
import com.library.application.persistence.CollaboratorRepository;
import com.library.application.persistence.ExpressionRepository;
import com.library.application.persistence.SubjectRepository;
import com.library.application.persistence.WRelationshipRepository;
import com.library.application.persistence.WorkRepository;


@Controller	// This means that this class is a Controller
@CrossOrigin
@RequestMapping(path="/expression") // This means URL's start with /demo (after Application path)
public class ExpressionController {
	@Autowired // This means to get the bean called userRepository
			   // Which is auto-generated by Spring, we will use it to handle the data
	private ExpressionRepository expressionRepository;
	
	@Autowired // This means to get the bean called userRepository
	   // Which is auto-generated by Spring, we will use it to handle the data
private CollaboratorRepository collaboratorRepository;
	@Autowired
	private WorkRepository workRepository;

	
	@PostMapping(path="/add") // Map ONLY POST Requests
	public @ResponseBody String addNewExpression (@RequestParam String title, @RequestParam Language language, @RequestParam Integer idParentWork, @RequestParam Integer idParentExpression, @RequestParam Set<Integer> idsCollaborators) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		/*
		 * (Work work, String title, Language language, Expression parent, Set<Collaborator> collaborators) {
		super();
		this.uniformTitle = uniformTitle;
		this.language = language;
		this.parent = parent;
		this.authors = authors;
		this.subjects = subjects;
	}
		 * 
		 */
		
		Expression e = new Expression();
		e.setTitle(title);
		e.setLanguage(language);
		
	
		
		 Iterable<Work> allWorks = workRepository.findAll();
			
			Work parentWork = new Work();
			 for (Work x : allWorks) {

				 if (x.getId() == idParentWork) {
					 parentWork = x;
				 }
		
			 }
			
			 e.setWork(parentWork);
			 
			 if (idParentExpression != null) {
			 
			 Iterable<Expression> allExpressions = expressionRepository.findAll();
				
			 
				Expression parentExpression = new Expression();
				 for (Expression x : allExpressions) {

					 if (x.getId() == idParentExpression) {
						 parentExpression = x;
					 }
			
				 }
				
				 e.setParent(parentExpression);
				 
			 } 

		
		Iterable<Collaborator> allCollaborators = collaboratorRepository.findAll();
		
		Set<Collaborator> expressionCollaborators = new HashSet<Collaborator>();
		 for (Collaborator x : allCollaborators) {
			 for (int i : idsCollaborators) {
			 if (x.getId() == i) {
				 expressionCollaborators.add(x);
			 }
			 }
		 }
		
		 e.setCollaborators(expressionCollaborators);
		 

		
		expressionRepository.save(e);
		return "Saved";
	}
	


	@GetMapping(path="/all")
	public @ResponseBody Iterable<Expression> getAllExpressions() {
		// This returns a JSON or XML with the users
		return expressionRepository.findAll();
	}
	
	//Expressions per id d'obra 
	@GetMapping(path="/{workId}")
	public @ResponseBody Iterable<Expression> getAllExpressionsFromWork(@PathVariable (value = "workId") Integer workId) {
		Iterable<Expression> allExpressions = expressionRepository.findAll();
		Set<Expression> expressionsFromWork = new HashSet<Expression>();
		
		 for (Expression x : allExpressions) {
			 if (x.getWork().getId() == workId) {
				 expressionsFromWork.add(x);
			 }
		 }
		return expressionsFromWork;
		
	}
	
	//Numero expressions per id d'obra 
	@GetMapping(path="/{workId}/number")
	public @ResponseBody Integer getNumberExpressionsFromWork(@PathVariable (value = "workId") Integer workId) {
		Iterable<Expression> allExpressions = expressionRepository.findAll();
		Set<Expression> expressionsFromWork = new HashSet<Expression>();
		
		 for (Expression x : allExpressions) {
			 if (x.getWork().getId() == workId) {
				 expressionsFromWork.add(x);
			 }
		 }
		return expressionsFromWork.size();
		
	}
	
	//Numero expressions per id d'autor 
	@GetMapping(path="/{authorId}/numberfromauthor")
	public @ResponseBody Integer getNumberExpressionsFromAuthor(@PathVariable (value = "authorId") Integer authorId) {
		Iterable<Work> allWorks = workRepository.findAll();
		Iterable<Expression> allExpressions = expressionRepository.findAll();
		Set<Expression> expressionsFromAuthor = new HashSet<Expression>();
		
		 for (Work w : allWorks) {
			 for (Author a : w.getAuthors()) {
				 if (a.getId() == authorId) {
					 
					 for (Expression e : allExpressions) {
						 if (e.getWork().getId() == w.getId()) {
							 expressionsFromAuthor.add(e);
						 }
					 }
					 
				 }
				 
			 }
			 
			 
			 
			 
		 }
		return expressionsFromAuthor.size();
		
	}


	
	//Obra per id d'expressi√≥
	@GetMapping(path="/{expressionId}/work")
	public @ResponseBody String getWorkFromExpression(@PathVariable (value = "expressionId") Integer expressionId) {
		
		Iterable<Expression> allExpressions = expressionRepository.findAll();
		Expression expressionWithId = new Expression();
		
		 for (Expression x : allExpressions) {
			 if (x.getId() == expressionId) {
				 expressionWithId = x;
			 }
		 }
		
		 
		return expressionWithId.getWork().toString();
		
	}
	
	//Set d'obres --> expressions
	@PostMapping("/works")
	public @ResponseBody ArrayList<Expression> getExpressionsFromWorks(@RequestBody ArrayList<Work> works){
		 //Iterable<Expression> getExpressionsFromWorks (@RequestBody Iterable<Work> works)
		
		 Iterable<Expression> allExpressions =  expressionRepository.findAll();
		 ArrayList<Expression> expressionsFromWorks = new ArrayList<Expression>();
//		 
		for (Expression e : allExpressions) {
			for (Work w : works) {
			if (e.getWork().getId() == w.getId()) {
					expressionsFromWorks.add(e);
			}
			}
//			
		}
//		 
	return expressionsFromWorks;
		//return null; 
	}
	
	

	

}