package com.library.application.controller;



import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.library.application.domain.Author;
import com.library.application.domain.Expression;
import com.library.application.domain.Song;
import com.library.application.domain.SongVersion;
import com.library.application.domain.Work;
import com.library.application.persistence.ExpressionRepository;
import com.library.application.persistence.SongRepository;
import com.library.application.persistence.WorkRepository;


@Controller	// This means that this class is a Controller
@CrossOrigin
@RequestMapping(path="/song") // This means URL's start with /demo (after Application path)
public class SongController {
	@Autowired // This means to get the bean called userRepository
	// Which is auto-generated by Spring, we will use it to handle the data
	private SongRepository songRepository;
	@Autowired
	private ExpressionRepository expressionRepository;
	@Autowired
	private WorkRepository workRepository;

	@PostMapping(path="/add") // Map ONLY POST Requests
	public @ResponseBody String addNewSong (@RequestParam String title, @RequestParam Set<Integer> idsExpressions) {

		//(String name, String publisher) 
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		Song s = new Song();
		s.setTitle(title);

		Iterable<Expression> allExpressions = expressionRepository.findAll();
		Set<Expression> sExpressions = new HashSet<Expression>();
		for (Expression x : allExpressions) {
			for (int i : idsExpressions) {
				if (x.getId() == i) {
					sExpressions.add(x);
				}
			}
		}
		s.setExpressions(sExpressions);



		songRepository.save(s);
		return "Saved";
	}



	@GetMapping(path="/all")
	public @ResponseBody Iterable<Song> getAllSongs() {
		// This returns a JSON or XML with the users
		return songRepository.findAll();
	}


	@GetMapping(path="/{songQuery}")
	public @ResponseBody Iterable<Song> getSongsFromQuery (@PathVariable (value = "songQuery") String songQuery) {
		Iterable<Song> allSongs = songRepository.findAll();
		ArrayList<Song> songsResultQuery = new ArrayList<>();
		for (Song s : allSongs) {
			if (s.getTitle() != null) {
				if (s.getTitle().contains(songQuery) || s.getTitle().toLowerCase().contains(songQuery) || s.getTitle().toUpperCase().contains(songQuery)) {
					songsResultQuery.add(s);	
				}
			} 
		}


		return songsResultQuery;

	}
	
	//a quins works apareix 1 song
	@GetMapping(path="/{songId}/works")
	public @ResponseBody Iterable<Work> getAllWorksFromSong(@PathVariable (value = "songId") Integer songId) {
		//Iterable<Work> allWorks = workRepository.findAll();
		//Iterable<Expression> allExpressions = expressionRepository.findAll();
		
		Iterable<Song> allSongs = songRepository.findAll();
		Song chosenSong = null;
		Set<Expression> expressionsfromSong = new HashSet<>();
		//Set<Work> worksfromSong = new HashSet<>();
		ArrayList<Work> worksFromSong = new ArrayList<>();
		for (Song s : allSongs) {
			if (s.getId() == songId) {
				chosenSong = s;
			}
		}
		expressionsfromSong = chosenSong.getExpressions();
		
		for (Expression e : expressionsfromSong) {
			worksFromSong.add(e.getWork());
			
		}
		
		return worksFromSong;
		

	}


	//number of works where 1 song appears
	@GetMapping(path="/{songId}/numberworks")
	public @ResponseBody int getNumberWorksFromSong(@PathVariable (value = "songId") Integer songId) {
		//Iterable<Work> allWorks = workRepository.findAll();
		//Iterable<Expression> allExpressions = expressionRepository.findAll();
		
		Iterable<Song> allSongs = songRepository.findAll();
		Song chosenSong = null;
		Set<Expression> expressionsfromSong = new HashSet<>();
		//Set<Work> worksfromSong = new HashSet<>();
		ArrayList<Work> worksFromSong = new ArrayList<>();
		for (Song s : allSongs) {
			if (s.getId() == songId) {
				chosenSong = s;
			}
		}
		expressionsfromSong = chosenSong.getExpressions();
		
		for (Expression e : expressionsfromSong) {
			worksFromSong.add(e.getWork());
			
		}
		
		return worksFromSong.size();
		

	}
	
}
