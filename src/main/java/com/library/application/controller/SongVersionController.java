package com.library.application.controller;



import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.library.application.domain.Author;
import com.library.application.domain.Expression;
import com.library.application.domain.Song;
import com.library.application.domain.SongVersion;
import com.library.application.domain.Work;
import com.library.application.persistence.ExpressionRepository;
import com.library.application.persistence.SongRepository;
import com.library.application.persistence.SongVersionRepository;


@Controller	// This means that this class is a Controller
@CrossOrigin
@RequestMapping(path="/songversion") // This means URL's start with /demo (after Application path)
public class SongVersionController {
	@Autowired // This means to get the bean called userRepository
	   // Which is auto-generated by Spring, we will use it to handle the data
private SongVersionRepository songVersionRepository;
	@Autowired
private ExpressionRepository expressionRepository;
	@Autowired
private SongRepository songRepository;

@PostMapping(path="/add") // Map ONLY POST Requests
public @ResponseBody String addNewSongVersion (@RequestParam String titleProper, @RequestParam Set<Integer> idsExpressions, @RequestParam Integer idSong, int minutes, int seconds) {

//(String name, String publisher) 
// @ResponseBody means the returned String is the response, not a view name
// @RequestParam means it is a parameter from the GET or POST request

SongVersion sv = new SongVersion();

sv.setTitleProper(titleProper);

Iterable<Expression> allExpressions = expressionRepository.findAll();

Set<Expression> svExpressions = new HashSet<Expression>();
 for (Expression x : allExpressions) {
	 for (int i : idsExpressions) {
	 if (x.getId() == i) {
		 svExpressions.add(x);
	 }
	 }
 }
 sv.setExpressions(svExpressions);

 Iterable<Song> allSongs = songRepository.findAll();
 Song svSong = new Song();
  for (Song x : allSongs) {
 	 
 	 if (x.getId() == idSong) {
 		 svSong = x;
 	 }
 	 
  }
sv.setSong(svSong);

sv.setMinutes(minutes);
sv.setSeconds(seconds);


songVersionRepository.save(sv);
return "Saved";
}



@GetMapping(path="/all")
public @ResponseBody Iterable<SongVersion> getAllSongVersions() {
// This returns a JSON or XML with the users
return songVersionRepository.findAll();
}

//Versions per id de cançó 
@GetMapping(path="/{songId}")
public @ResponseBody Iterable<SongVersion> getAllVersionsFromSong(@PathVariable (value = "songId") Integer songId) {
	Iterable<SongVersion> allVersions = songVersionRepository.findAll();
	Set<SongVersion> versionsFromSong = new HashSet<SongVersion>();
	
	 for (SongVersion x : allVersions) {
		 if (x.getSong().getId() == songId) {
			 versionsFromSong.add(x);
		 }
	 }
	return versionsFromSong;
	
}

//Numero versions per id de cançó 
@GetMapping(path="/{songId}/number")
public @ResponseBody Integer getNumberVersionsFromSong(@PathVariable (value = "songId") Integer songId) {
	Iterable<SongVersion> allVersions = songVersionRepository.findAll();
	Set<SongVersion> versionsFromSong = new HashSet<SongVersion>();
	
	 for (SongVersion x : allVersions) {
		 if (x.getSong().getId() == songId) {
			 versionsFromSong.add(x);
		 }
	 }
	return versionsFromSong.size();
	
}

//a quins works apareix 1 version
	@GetMapping(path="/{versionId}/works")
	public @ResponseBody Iterable<Work> getAllWorksFromSong(@PathVariable (value = "versionId") Integer versionId) {
		//Iterable<Work> allWorks = workRepository.findAll();
		//Iterable<Expression> allExpressions = expressionRepository.findAll();
		
		Iterable<SongVersion> allVersions = songVersionRepository.findAll();
		SongVersion chosenVersion = null;
		Set<Expression> expressionsfromVersion = new HashSet<>();
		//Set<Work> worksfromSong = new HashSet<>();
		ArrayList<Work> worksFromVersion = new ArrayList<>();
		for (SongVersion v : allVersions) {
			if (v.getId() == versionId) {
				chosenVersion = v;
			}
		}
		expressionsfromVersion = chosenVersion.getExpressions();
		
		for (Expression e : expressionsfromVersion) {
			worksFromVersion.add(e.getWork());
			
		}
		
		return worksFromVersion;
		

	}
	
	//a quants works apareix 1 version
		@GetMapping(path="/{versionId}/numberworks")
		public @ResponseBody int getNumberWorksFromSong(@PathVariable (value = "versionId") Integer versionId) {
			//Iterable<Work> allWorks = workRepository.findAll();
			//Iterable<Expression> allExpressions = expressionRepository.findAll();
			
			Iterable<SongVersion> allVersions = songVersionRepository.findAll();
			SongVersion chosenVersion = null;
			Set<Expression> expressionsfromVersion = new HashSet<>();
			//Set<Work> worksfromSong = new HashSet<>();
			ArrayList<Work> worksFromVersion = new ArrayList<>();
			for (SongVersion v : allVersions) {
				if (v.getId() == versionId) {
					chosenVersion = v;
				}
			}
			expressionsfromVersion = chosenVersion.getExpressions();
			
			for (Expression e : expressionsfromVersion) {
				worksFromVersion.add(e.getWork());
				
			}
			
			return worksFromVersion.size();
			

		}	


}